## 考えたこと（自分の最初の振る舞いに自覚的になろう）

- まず，一つのstackだけを使う場合を考えてみる．
    - stackが空の初期状態から考えて，push呼び出しが続くときはそのまま上に積んでいく．pop呼び出しが呼ばれたとき，stackのデータを順番を入れ替える用のstackを作ってstackの中身を逆順に更新して，stackからpopしたものを返す．
    - ここから呼び出される操作が変わるたびにstackの中身を逆順にしていく．
    - pushとpopが交互に呼ばれた場合，その時点に保存されているデータ量がかかってしまうと思う．

<br>

- 次に，2つのスタックを使った場合を考えてみる．
    - 考えがまとまらなかったので，以下の方法でChatGPTに質問してみた．
    - 具体的な解法やコードは書かかないようにという条件を付けて，どのような問いを考えることで頼んでみた．その問いに対して以下の「役割分担を考える」という問いが，自分に足りてない考え方で，この考え方を使ってもう一度考えてみようと思った．

    - 以下ChatGPTからの引用です．

    > 3. 役割分担を考える</br>
    > 2つのスタックがある場合、それぞれに役割を持たせると効率的に動作します。</br>
    > 問い:</br>
    > 1つのスタックに新しい要素を追加するとしたら、もう1つのスタックはどのように機能すればいいか？</br>
    > 要素の順序をどのように保つか？</br>

<br>

- 今まで漠然と二つのスタックを使ってパズルの感覚で処理を考えていたが，ここで二つのスタックに対して，入力の保存用と返却用の役割を持たせて考えてみようと思った．役割をはっきりさせることで頭の中が整理されたように思う．

## 方針・手順の整理（どういう理由でどの選択肢を選んだかなど）

- 2つのスタックに対して，入力保存用と返却用の役割を持たせる．
- 保存用と返却用を空で初期化した状態から考え始める．pushが呼ばれ続けている間は保存用に追加していく．popが呼ばれたタイミングで保存用のデータを返却用のスタックに逆順でコピーして，保存用を空にする．その後返却用のスタックからデータを取り出して返却する．
- 懸念したこと：
    - 保存用のデータを返却用に移す処理は，pushが呼ばれたときでいいのかなと思った．
    - 返却用のスタックに値が一つでも残っている状態で，push操作が増え続けると二つのスタックのバランスが悪くなると思った．
- 保存用の役割について，ただの保存用というよりバッファーの役割を果たしていると思ったので変数名はbuffer_stackにしようと思った．

## Step1を終えて感じたこと（一番最初どんな振る舞いをしたのか，どこで間違えたか，どこに不満を持ってどのように修正したか，など）

- peekの実装でoutput_stackが空の場合と空じゃない場合を分けて考えることができていなくてエラーを出してしまった．またbuffer_stackから返す処理を最初buffer_stack[-1]で書いてしまった．現状これらのことは身体性をもって具体的な状況をイメージせずにコードだけを見て修正している限り間違え続けるなと思ったので，ちゃんと状況をイメージしようと思った．

- Amortized time complexityについて整理できていなかったので調べた．
    - Wikipedia: Amorized analysis
        - https://en.wikipedia.org/wiki/Amortized_analysis
    - StackOverflow: What is amortized analysis of algorithms? [closed]
        - https://stackoverflow.com/questions/11102585/what-is-amortized-analysis-of-algorithms

    - Amortized analysisのモチベーションとしてworst-caseだけを見るのは悲観的過ぎるというものがあるようだ．Amortized analysisは各操作を個別にみてその中のworst-caseに注目するのではなく，一連の操作における一回当たりの平均のコストに注目する，という認識を持った．
    - このLeetCodeの問題で考えると，output_stackが空になりbuffer_stackをoutpus_stackにコピーすることでその時点におけるO(n)のコストがかかる．しかしその後，次にoutput_stackが空になるまで，output_stackから取り出す操作をO(1)のコストでn回実行することができる.よってoutput_stackから取り出す操作をAmortized O(1) と呼んでよいと思う．

    - WikipediaのExamplesにqueueをstackで実装する事例が紹介されていた．今回の問題の出題意図として，queueをstackで実装することを通して，Amorized analysisの考え方に触れてほしいというものがあったのかなと思った．最初は何故queueをstackで実装しないといけないんだろうと不満を感じてしまったが，それは何かをやること自体に価値があるという考えが強かったのかなと思った．意図や背景を考えて，それらを受け取れたと感じると穏やかな気持ちになれた．今後もそういう気持ちになるために調べる習慣をつけようと思った．

## Step2を終えて感じたこと（他の人のコードとコメントを見て感じたこと，参考にしたこと，Step1でどのように振る舞っていればよかったかなど）


## Step3を終えて感じたこと（ゼロから10分以内でノーミスで3回書き上げる練習をする中で自然に思えず修正したとこ，他の人がどのような反応をするかを想像して修正したところなど）


## ここでレビュー依頼を出す


## プルリクエストを出して，コメントをもらった後に感じたこと（考え方のことなる実装の方法でもコードを書いてみる）


## Web上で調べたこと
